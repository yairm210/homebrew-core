diff --git a/extern/samtools-1.3.1/htslib-1.3.1/bgzf.c b/extern/samtools-1.3.1/htslib-1.3.1/bgzf.c
index a6c8897..b06dde9 100644
--- a/extern/samtools-1.3.1/htslib-1.3.1/bgzf.c
+++ b/extern/samtools-1.3.1/htslib-1.3.1/bgzf.c
@@ -234,7 +234,6 @@ static BGZF *bgzf_write_init(const char *mode)
 BGZF *bgzf_open(const char *path, const char *mode)
 {
     BGZF *fp = 0;
-    assert(compressBound(BGZF_BLOCK_SIZE) < BGZF_MAX_BLOCK_SIZE);
     if (strchr(mode, 'r')) {
         hFILE *fpr;
         if ((fpr = hopen(path, mode)) == 0) return 0;
@@ -257,7 +256,6 @@ BGZF *bgzf_open(const char *path, const char *mode)
 BGZF *bgzf_dopen(int fd, const char *mode)
 {
     BGZF *fp = 0;
-    assert(compressBound(BGZF_BLOCK_SIZE) < BGZF_MAX_BLOCK_SIZE);
     if (strchr(mode, 'r')) {
         hFILE *fpr;
         if ((fpr = hdopen(fd, mode)) == 0) return 0;
@@ -280,7 +278,6 @@ BGZF *bgzf_dopen(int fd, const char *mode)
 BGZF *bgzf_hopen(hFILE *hfp, const char *mode)
 {
     BGZF *fp = NULL;
-    assert(compressBound(BGZF_BLOCK_SIZE) < BGZF_MAX_BLOCK_SIZE);
     if (strchr(mode, 'r')) {
         fp = bgzf_read_init(hfp);
         if (fp == NULL) return NULL;
@@ -295,42 +292,73 @@ BGZF *bgzf_hopen(hFILE *hfp, const char *mode)
     return fp;
 }
 
+static inline void u16_to_le(uint16_t val, uint8_t *buf) {
+#if defined(HTS_LITTLE_ENDIAN) && HTS_ALLOW_UNALIGNED != 0
+    *((uint16_u *) buf) = val;
+#else
+    buf[0] = val & 0xff;
+    buf[1] = (val >> 8) & 0xff;
+#endif
+}
+
 int bgzf_compress(void *_dst, size_t *dlen, const void *src, size_t slen, int level)
 {
     uint32_t crc;
     z_stream zs;
     uint8_t *dst = (uint8_t*)_dst;
 
-    // compress the body
-    zs.zalloc = NULL; zs.zfree = NULL;
-    zs.msg = NULL;
-    zs.next_in  = (Bytef*)src;
-    zs.avail_in = slen;
-    zs.next_out = dst + BLOCK_HEADER_LENGTH;
-    zs.avail_out = *dlen - BLOCK_HEADER_LENGTH - BLOCK_FOOTER_LENGTH;
-    int ret = deflateInit2(&zs, level, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY); // -15 to disable zlib header/footer
-    if (ret!=Z_OK) {
-        if (hts_verbose >= 1) {
-            fprintf(stderr, "[E::%s] deflateInit2 failed: %s\n",
-                    __func__, bgzf_zerr(ret, &zs));
+    if (level == 0) {
+    uncomp:
+        // Uncompressed data
+        if (*dlen < slen+5 + BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH) return -1;
+        dst[BLOCK_HEADER_LENGTH] = 1; // BFINAL=1, BTYPE=00; see RFC1951
+        u16_to_le(slen,  &dst[BLOCK_HEADER_LENGTH+1]); // length
+        u16_to_le(~slen, &dst[BLOCK_HEADER_LENGTH+3]); // ones-complement length
+        memcpy(dst + BLOCK_HEADER_LENGTH+5, src, slen);
+        *dlen = slen+5 + BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH;
+    } else {
+        // compress the body
+        zs.zalloc = NULL; zs.zfree = NULL;
+        zs.msg = NULL;
+        zs.next_in  = (Bytef*)src;
+        zs.avail_in = slen;
+        zs.next_out = dst + BLOCK_HEADER_LENGTH;
+        zs.avail_out = *dlen - BLOCK_HEADER_LENGTH - BLOCK_FOOTER_LENGTH;
+        int ret = deflateInit2(&zs, level, Z_DEFLATED, -15, 8, Z_DEFAULT_STRATEGY); // -15 to disable zlib header/footer
+        if (ret!=Z_OK) {
+            if (hts_verbose >= 1) {
+                fprintf(stderr, "[E::%s] deflateInit2 failed: %s\n",
+                        __func__, bgzf_zerr(ret, &zs));
+            }
+            return -1;
         }
-        return -1;
-    }
-    if ((ret = deflate(&zs, Z_FINISH)) != Z_STREAM_END) {
-        if (hts_verbose >= 1) {
-            fprintf(stderr, "[E::%s] deflate failed: %s\n",
-                    __func__, bgzf_zerr(ret, ret == Z_DATA_ERROR ? &zs : NULL));
+        if ((ret = deflate(&zs, Z_FINISH)) != Z_STREAM_END) {
+            if (ret == Z_OK && zs.avail_out == 0) {
+                deflateEnd(&zs);
+                goto uncomp;
+            } else if (hts_verbose >= 1) {
+                fprintf(stderr, "[E::%s] deflate failed: %s\n",
+                        __func__, bgzf_zerr(ret, ret == Z_DATA_ERROR ? &zs : NULL));
+            }
+            return -1;
         }
-        return -1;
-    }
-    if ((ret = deflateEnd(&zs)) != Z_OK) {
-        if (hts_verbose >= 1) {
-            fprintf(stderr, "[E::%s] deflateEnd failed: %s\n",
-                    __func__, bgzf_zerr(ret, NULL));
+        // If we used up the entire output buffer, then we either ran out of
+        // room or we *just* fitted, but either way we may as well store
+        // uncompressed for faster decode.
+        if (zs.avail_out == 0) {
+            deflateEnd(&zs);
+            goto uncomp;
         }
-        return -1;
+        if ((ret = deflateEnd(&zs)) != Z_OK) {
+            if (hts_verbose >= 1) {
+                fprintf(stderr, "[E::%s] deflateEnd failed: %s\n",
+                        __func__, bgzf_zerr(ret, NULL));
+            }
+            return -1;
+        }
+        *dlen = zs.total_out + BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH;
     }
-    *dlen = zs.total_out + BLOCK_HEADER_LENGTH + BLOCK_FOOTER_LENGTH;
+
     // write the header
     memcpy(dst, g_magic, BLOCK_HEADER_LENGTH); // the last two bytes are a place holder for the length of the block
     packInt16(&dst[16], *dlen - 1); // write the compressed length; -1 to fit 2 bytes
